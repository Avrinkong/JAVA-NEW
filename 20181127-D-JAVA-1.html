<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">
    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
         <section class="present" style="top: 221.5px; display: block;">
            <h2>Spring中的IOC是什么意思</h2>
            <p>分享人：汪天驰</p>	
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 69px; display: block;">
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>            
            <p>4.编码实战</p>
            <p>5.扩展思考</p>
            <p>6.参考文献</p>
            <p>7.更多讨论</p>
        </section>	       
		<section hidden="" aria-hidden="true" class="future" style="top: 267px; display: block;">
			<h3>1.背景介绍</h3>
			
		</section>	     

		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    
            <p style="text-align:left; ">
			 Spring是一个开源的轻量级Java SE（Java 标准版本）/Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。</br>
			 应用程序是由一组相互协作的对象组成。</br>
			 Spring框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，
			 还能帮我管理最头疼的数据库事务，本身提供了一套简单的JDBC访问实现，提供与第三方数据访问框架集成（如Hibernate、JPA），与各种Java EE技术整合（如Java Mail、任务调度等等），提供一套自己的web层框架Spring MVC、而且还能非常简单的与第三方web框架集成。</br>
			 从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。</br>
			
			</p>

		</section>
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>Spring IOC</h3>
			<p style="text-align:left; ">
			 SpringIOC-Iversion of Control</br>
　　即“控制反转”，不是什么技术，而是一种设计思想。</br>
在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。
如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</br>
　　谁控制谁，控制什么：</br>
传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；</br>
而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；</br>

			</p>
		</section>
		
		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    
            <p style="text-align:left; ">
			 谁控制谁？</br>
当然是IoC 容器控制了对象；</br>
控制什么？</br>
那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</br>
　  为何是反转，哪些方面反转了：</br>
有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；</br>
而反转则是由容器来帮忙创建及注入依赖对象；</br>
为何是反转？</br>
因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；</br>
哪些方面反转了？</br>
依赖对象的获取被反转了。</br>
			</p>

		</section>
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>2.知识剖析</h3>
			<p></p>
		</section>
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">			
			<p style="text-align:left; ">
			结构示意图</br>
			<img src="https://images2017.cnblogs.com/blog/1209363/201707/1209363-20170731165715833-1457660968.png">
			</p>
		</section>
		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    <h3>IOC的作用：</h3>
            <p style="text-align:left; ">
            1　IoC 是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。</br>
			传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；</br>
			有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，</br>
			所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</br>
			 

			</p>
		</section>

		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    
            <p style="text-align:left; ">
			IOC容器也是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</br>
			 应用程序无需直接在代码中new相关的对象，应用程序由IOC容器进行组装。在Spring中BeanFactory是IOC容器的实际代表者。</br>
Spring IOC容器如何知道哪些是它管理的对象呢？</br>
这就需要配置文件，Spring IOC容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。</br>
一般使用基于xml配置文件进行配置元数据，而且Spring与配置文件完全解耦的，可以使用其他任何可能的方式进行配置元数据，比如注解、基于java文件的、基于属性文件的配置都可以。</br>
			</p>

		</section>
		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    <h3>DI：依赖注入</h3>
            <p style="text-align:left; ">
           
依赖注入（DI）是一种实现IOC的技术手段。</br>
理解DI的关键：谁依赖谁，为什么需要依赖，谁注入谁，注入了什么？</br>
①.谁依赖谁？应用程序依赖于IoC容器。</br>
让spring创建sqlsession bean。也就是通过SqlSessionFactory创建SqlSession</br>
②.为什么需要依赖？应用程序需要IoC容器来提供对象需要的外部资源（包括对象，文件等）。</br>
③.谁注入谁？IoC容器注入应用程序某个对象，应用程序依赖的对象。</br>
④.注入了什么？注入某个对象所需要的外部资源（包括对象、资源、变量数据）</br>

			</p>
		</section>
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>3.常见问题</h3>
		</section>
		
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">			
			<h3> 1 spring中的BeanFactory与ApplicationContext的作用和区别？ </h3>
		</section>
		
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">			
			<p style="text-align:left; ">
			 BeanFactory负责读取bean配置文档，管理bean的加载，实例化，维护bean之间的依赖关系，负责bean的声明周期。</br>
			 2. ApplicationContext除了提供上述BeanFactory所能提供的功能之外，还提供了更完整的框架功能：</br>
			 比如资源访问，事件传递，通过ApplicationContext扩展了ResourceLoader(资源加载器)接口。 </br>
			 3. ApplicationContext的初始化和BeanFactory有一个重大的区别:BeanFactory在初始化容器时，并未实例化Bean,直到第一次访问某个Bean时才实例目标Bean;</br>
			 而ApplicationContext则在初始化应用上下文时就实例化所有的单实例的Bean。</br>
			 因此ApplicationContext的初始化时间会比BeanFactory稍长一些. .Spring容器能够自动装配相互合作的bean，</br>
			 这意味着容器不需要construor-arg和property配置，能通过Bean工厂自动处理bean之间的协作 </br>
			</p>
		</section>
		
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">			
			<p style="text-align:left; ">
			2 什么是自动装配 .</br>

Spring容器能够自动装配相互合作的bean，这意味着容器不需要construor-arg和property配置，能通过Bean工厂自动处理bean之间的协作</br>
			</p>
		</section>
	
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>4.编码实战</h3>   			
		</section>
		
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>5.扩展思考</h3>
			IOC的优点</p>

IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。
最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。 </p>
		</section>
		
		
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>6.参考文献</h3>
			<p>http://www.cnblogs.com/chenssy/p/9576769.html</p>
		</section>        
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h3>7.更多讨论</h3>
        </section>
        
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h4>分享到此结束</h4>
            <p>谢谢大家！</p>            
        </section>
      
      

    </div>
</div>


<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }
    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            {src: '../plugin/markdown/marked.js'},
            {src: '../plugin/markdown/markdown.js'},
            {src: '../plugin/notes/notes.js', async: true},
            {
                src: '../plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            }
        ]
    });
</script>
</body>
</html>
