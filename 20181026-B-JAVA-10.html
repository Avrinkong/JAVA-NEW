<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
    <map name="pttmap">
        <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank" />
    </map>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>什么是IO流？</h2>
                <h3>小课堂</h3>
                <p>分享人：李浩</p>
            </section>
            <section>
                <p>1.背景介绍</p>
                <p>2.知识剖析</p>
                <p>3.常见问题</p>
                <p>4.解决方案</p>
                <p>5.编码实战</p>
                <p>6.扩展思考</p>
                <p>7.参考文献</p>
                <p>8.更多讨论</p>
            </section>

            <!-- **************************************************** -->
            <section>

            <section>
                <h3>1.背景介绍</h3>
            </section>

            <section>
                <h4>什么是流</h4>
                <p>流就是一系列的数据</p>
                <p>
                    当不同的介质之间有数据交互的时候，JAVA就使用流来实现。
                    数据源可以是文件，还可以是数据库，网络甚至是其他的程序。                    
                    比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流。

                    输入流： InputStream
                    输出流：OutputStream
                </p>
            </section>

            <section>
                <h4>文件输入流</h4>
                <p>
                    如下代码，就建立了一个文件输入流，这个流可以用来把数据从硬盘的文件，读取到JVM(内存)。                    
                    目前代码只是建立了流，还没有开始读取。
                </p>

                <section>
                    <pre>
                    <code class="hljs actionscript">
                        package stream;
                        
                        import java.io.File;
                        import java.io.FileInputStream;
                        import java.io.IOException;
                        
                        public class TestStream {
                        
                        public static void main(String[] args) {
                        try {
                        File f = new File("d:/lol.txt");
                        // 创建基于文件的输入流
                        FileInputStream fis = new FileInputStream(f);
                        // 通过这个输入流，就可以把数据从硬盘，读取到Java的虚拟机中来，也就是读取到内存中
                        
                        } catch (IOException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                        }
                        
                        }
                        }
                                    
                    </code>
                            </pre>
                </section>




            </section>

                <section>
                    <img src="img-java\io\5678.png" alt="">
                </section>

            </section>
            
            <!-- **************************************************** -->


            <section>
            <section>
                <h3>2.知识剖析</h3>
            </section>

            <section>
                <h2>字节流</h2>
                <p> 
                    InputStream字节输入流
                    OutputStream字节输出流
                    用于以字节的形式读取和写入数据
                </p>
            </section>

            <section>
                <h4>ASCII码 概念</h4>
                <p>
                    <br>
                    所有的数据存放在计算机中都是以数字的形式存放的。 所以字母就需要转换为数字才能够存放。
                    比如A就对应的数字65，a对应的数字97. 不同的字母和符号对应不同的数字，就是一张码表。
                    ASCII是这样的一种码表。 只包含简单的英文字母，符号，数字等。 不包含中文，德文，俄语等复杂的。
                    
                    <br>
                </p>
            </section>

            <section>
                <h4>以字节流的形式读取文件内容</h4>
                <p>
                
                    InputStream是字节输入流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。
                    FileInputStream 是InputStream子类，以FileInputStream 为例进行文件读取
                </p>
            </section>

            <section>
                <h4>以字节流的形式向文件写入数据</h4>
                <p>
            OutputStream是字节输出流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。
            FileOutputStream 是OutputStream子类，以FileOutputStream 为例向文件写出数据
            
            注: 如果文件d:/lol2.txt不存在，写出操作会自动创建该文件。
            但是如果是文件 d:/xyz/lol2.txt，而目录xyz又不存在，会抛出异常
                </p>
            </section>

            
                <section>
                    <h4>数据流</h4>
                    <p>
                        DataInputStream 数据输入流
                        DataOutputStream 数据输出流
                    </p>
                </section>
                
                
                <section>
                    <h4>直接进行字符串的读写</h4>
                    <p>
                        使用数据流的writeUTF()和readUTF() 可以进行数据的格式化顺序读写
                        如本例，通过DataOutputStream 向文件顺序写出 布尔值，整数和字符串。 然后再通过DataInputStream 顺序读入这些数据。
                        
                        注： 要用DataInputStream 读取一个文件，这个文件必须是由DataOutputStream 写出的，否则会出现EOFException，因为DataOutputStream
                        在写出的时候会做一些特殊标记，只有DataInputStream 才能成功的读取。
                    </p>
                </section>


                <section>
                    <h4>对象流</h4>
                    <p>
                        对象流指的是可以直接把一个对象以流的形式传输给其他的介质，比如硬盘
                        
                        一个对象以流的形式进行传输，叫做序列化。 该对象所对应的类，必须是实现Serializable接口
                    </p>
                </section>

                <section>
                    <h4>序列化一个对象</h4>
                    <p>
                        把一个对象序列化有一个前提是：这个对象的类，必须实现了Serializable接口
                    </p>
                </section>
                
            






                <section>
                    <h2>字符流</h2>
                    <p>
                        Reader字符输入流
                        Writer字符输出流
                        专门用于字符的形式读取和写入数据
                    </p>
                </section>
            
                
                <section>
                    <h4>使用字符流读取文件</h4>
                    <p>
                            FileReader 是Reader子类，以FileReader 为例进行文件读取
                    </p>
                </section>
                
                <section>
                    <h4>使用字符流把字符串写入到文件</h4>
                    <p>
                        FileWriter 是Writer的子类，以FileWriter 为例把字符串写入到文件
                    </p>
                </section>


                <section>
                    <h4>缓存流</h4>
                    <p>
                    以介质是硬盘为例，字节流和字符流的弊端：
                    在每一次读写的时候，都会访问硬盘。 如果读写的频率比较高的时候，其性能表现不佳。
                    
                    为了解决以上弊端，采用缓存流。
                    缓存流在读取的时候，会一次性读较多的数据到缓存中，以后每一次的读取，都是在缓存中访问，直到缓存中的数据读取完毕，再到硬盘中读取。
                    
                    就好比吃饭，不用缓存就是每吃一口都到锅里去铲。用缓存就是先把饭盛到碗里，碗里的吃完了，再到锅里去铲
                    
                    缓存流在写入数据的时候，会先把数据写入到缓存区，直到缓存区达到一定的量，才把这些数据，一起写入到硬盘中去。按照这种操作模式，就不会像字节流，字符流那样每写一个字节都访问硬盘，从而减少了IO操作
                    </p>
                </section>
                
                
                <section>
                    <h4>使用缓存流读取数据</h4>
                    <p>
                        缓存字符输入流 BufferedReader 可以一次读取一行数据
                    </p>
                </section>
                
                <section>
                    <h4>使用缓存流写出数据</h4>
                    <p>
                        PrintWriter 缓存字符输出流， 可以一次写出一行数据                    
                    </p>
                </section>
                <section>
                    <h4>flush</h4>
                    <p>
                        有的时候，需要立即把数据写入到硬盘，而不是等缓存满了才写出去。 这时候就需要用到flush
                    </p>
                </section>




            </section>



            <!-- **************************************************** -->
            <section>
            <section>
                <h3>3.常见问题</h3>
            </section>

            <section>
                <p>如何关闭流</p>
            
                <p>
                    所有的流，无论是输入流还是输出流，使用完毕之后，都应该关闭。 如果不关闭，会产生对资源占用的浪费。 当量比较大的时候，会影响到业务的正常开展。
                </p>
            </section>

            </section>



            <!-- **************************************************** -->
        
            <section>
                
            <section>
                <h3>4.解决方案</h3>
            </section>
            <section>
                <p>在try中关闭</p>
                <p>
                    在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端；
                    如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 不推荐使用
                </p>
            </section>
            
            <section>
                <p>在finally中关闭</p>
            
                <p>
                    这是标准的关闭流的方式
                    1. 首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally.
                    2. 在finally关闭之前，要先判断该引用是否为空
                    3. 关闭的时候，需要再一次进行try catch处理
            
                    这是标准的严谨的关闭流的方式，但是看上去很繁琐，所以写不重要的或者测试代码的时候，都会采用上面的有隐患try的方式，因为不麻烦~
            
                </p>
            </section>

            <section>
                <p>使用try()的方式</p>
                <p>
                    把流定义在try()里,try,catch或者finally结束的时候，会自动关闭
                    这种编写代码的方式叫做 try-with-resources， 这是从JDK7开始支持的技术
                    
                    所有的流，都实现了一个接口叫做 AutoCloseable，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。
                </p>
            </section>


            </section>
            <!-- **************************************************** -->

            <section>
                <h3>5.编码实战</h3>
                <h1>Code</h1>
            </section>

            <!-- **************************************************** -->

            <section>

            <section>
                <h3>6.拓展思考</h3>
            </section>
            
            <section>
                <h4>System.in</h4>
            </section>

            <section>
                <p>
                System.out 是常用的在控制台输出数据的
                System.in 可以从控制台输入数据
                </p>
                <h4>使用System.in.read虽然可以读取数据，但是很不方便。使用Scanner就可以逐行读取了</h4>
            </section>

            </section>
            <!-- **************************************************** -->


            <section>
                <h3>7.参考文献</h3>
                <p>how2j.cn: http://how2j.cn/k/io/io-system-in/352.html#nowhere</p>
            </section>


            <!-- **************************************************** -->

            <section>
                <h3>8.更多讨论</h3>
                <p>欢迎师兄加入讨论</p>
            </section>

            <!-- **************************************************** -->

            <section>
                <p>感谢大家观看</p>
                <p>BY : 李浩</p>
            </section>

        </div>
    </div>

    <script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
    <script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

    <script>

        // 以下为常见配置属性的默认值
        // {
        // 	controls: true, // 是否在右下角展示控制条
        // 	progress: true, // 是否显示演示的进度条
        // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
        // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
        // 	keyboard: true, // 是否启用键盘快捷键来导航
        // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
        // 	center: true, // 是否将幻灯片垂直居中
        // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
        // 	loop: false, // 是否循环演示
        // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
        // 	fragments: true, // 全局开启和关闭碎片。
        // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
        // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
        // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
        // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
        // }

        // 初始化幻灯片
        Reveal.initialize({
            history: true,
            dependencies: [
                { src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js' },
                { src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js' },
                { src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true },
                { src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
            ]
        });
    </script>
</body>

</html>