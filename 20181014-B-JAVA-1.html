<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
    <map name="pttmap">
        <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank" />
    </map>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>Map、Set、List、Queue、Stack的特点与用法</h2>
                <h3>小课堂</h3>
                <p>分享人：李浩</p>
            </section>
            <section>
                <p>1.背景介绍</p>
                <p>2.知识剖析</p>
                <p>3.常见问题</p>
                <p>4.解决方案</p>
                <p>5.编码实战</p>
                <p>6.扩展思考</p>
                <p>7.参考文献</p>
                <p>8.更多讨论</p>
            </section>

            <!-- **************************************************** -->
            <section>

            <section>
                <h3>1.背景介绍</h3>
            </section>

            <section>
                <h4>Map</h4>
                <p>
                    Map用于保存具有"映射关系"的数据，因此Map集合里保存着两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value。
                    key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较结果总是返回false。
                    </p>
                    <p>
                    关于Map，我们要从代码复用的角度去理解，java是先实现了Map，然后通过包装了一个所有value都为null的Map就实现了Set集合
                    Map的这些实现类和子接口中key集的存储形式和Set集合完全相同(即key不能重复)
                    Map的这些实现类和子接口中value集的存储形式和List非常类似(即value可以重复、根据索引来查找)
                </p>
            </section>

            <section>
                <h4>Set</h4>
                <p>
                    Set集合类似于一个罐子，"丢进"Set集合里的多个对象之间没有明显的顺序。Set继承自Collection接口，不能包含有重复元素(记住，这是整个Set类层次的共有属性)。
                    Set判断两个对象相同不是使用"=="运算符，而是根据equals方法。也就是说，我们在加入一个新元素的时候，如果这个新元素对象和Set中已有对象进行注意equals比较都返回false，则Set就会接受这个新元素对象，否则拒绝。
                 </p>
                <p>
                    因为Set的这个制约，在使用Set集合的时候，应该注意两点：1) 为Set集合里的元素的实现类实现一个有效的equals(Object)方法、2)
                    对Set的构造函数，传入的Collection参数不能包含重复的元素
                </p>
            </section>

            <section>
                <h4>List</h4>
                <p>
                    List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。
                    List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。List集合默认按元素的添加顺序设置元素的索引。
                    </p>
                    <p>
                    如果涉及到“栈”、“队列”、“链表”等操作，请优先考虑用 List。至于是用哪个 List 则分如下：
                    1、对于需要快速插入、删除元素，则需使用 LinkedList。
                    2、对于需要快速访问元素，则需使用 ArrayList。
                    3、对于“单线程环境”或者“多线程环境，但是 List 仅被一个线程操作”，需要考虑使用非同步的类，
                    如果是“多线程环境，切 List 可能同时被多个线程操作”，考虑使用同步的类（如Vector）。
                </p>
            </section>

            <section>
                <h4>Stack</h4>
                <p>
                    Stack是Vector提供的一个子类，用于模拟"栈"这种数据结构(后进先出LIFO)
                    <br>方法:push、pop、peek、empty、seatch
                </p>
            </section>

            <section>
                <h4>Queue</h4>
                <p> Queue用于模拟"队列"这种数据结构(先进先出FIFO)。队列的头部保存着队列中存放时间最长的元素，队列的尾部保存着队列中存放时间最短的元素。
                    新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素，队列不允许随机访问队列中的元素。结合生活中常见的排队就会很好理解这个概念
                </p>
            </section>

            </section>
            
            <!-- **************************************************** -->


            <section>
            <section>
                <h3>2.知识剖析</h3>
            </section>
            <section>
                <h4>Map常用子类，HashMap</h4>
                <p> 和HashSet集合不能保证元素的顺序一样，HashMap也不能保证key-value对的顺序。
                    并且类似于HashSet判断两个key是否相等的标准也是:两个key通过equals()方法比较返回true、同时两个key的hashCode值也必须相等</p>
                <p>
                    HashMap常用方法：put、get、remove
                </p>
            </section>

            
            <section>
                <h4>Set常用实例化子类--HashSet</h4>
                <p>
                    <br>
                    HashSet是Set接口的典型实现，HashSet使用HASH算法来存储集合中的元素，因此具有良好的存取和查找性能。
                    当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。
                    值得注意的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等
                    <br>它包含的方法：contains、add、remove、clear、clone、isEmpty、size、toArray
                </p>
            </section>

            <section>
                <h4>List常用实例子类--ArrayList</h4>
                <p>
                    ArrayList是基于数组实现的List类，它封装了一个动态的增长的、允许再分配的Object[]数组。 </p>
                <p>Vector和ArrayList在用法上几乎完全相同，但由于Vector是一个古老的集合，所以Vector提供了一些方法名很长的方法，
                    但随着JDK1.2以后，java提供了系统的集合框架，就将Vector改为实现List接口，统一归入集合框架体系中</p>
            </section>



            </section>
            <!-- **************************************************** -->
            <section>
            <section>
                <h3>3.常见问题</h3>
            </section>

            <section>
                <p>List、Set、Map的区别</p>
            
                <p>
                    List：
                    <p style="text-align: left;">
                        1.可以允许重复的对象。
                    </p>
                    <p style="text-align: left;">
                        2.可以插入多个null元素。
                    </p>
                    <p style="text-align: left;">
                        3.是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。
                    </p>
                    <p style="text-align: left;">
                        4.常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，
                        而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。
                    </p>
            
                </p>
            </section>

            <section>
                <p>List、Set、Map的区别</p>
            
                <p>
                    Set：
                    <p style="text-align: left;">
                        1.不允许重复对象
                    </p>
                    <p style="text-align: left;">
                        2. 无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序。
                    </p>
                    <p style="text-align: left;">
                        3. 只允许一个 null 元素
                    </p>
                    <p style="text-align: left;">
                        4.Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。
                        最流行的是基于 HashMap 实现的 HashSet；TreeSet还实现了SortedSet接口，
                        因此 TreeSet是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。
                    </p>
            
                </p>
            </section>

            <section style="font-size: 2.2rem;">
                <p>List、Set、Map的区别</p>
            
                <p>
                    Map：
                    <p style="text-align: left;">
                        1.Map不是collection的子接口或者实现类。Map是一个接口。
                    </p>
                    <p style="text-align: left;">
                        2.Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的。
                    </p>
                    <p style="text-align: left;">
                        3. TreeMap 也通过 Comparator 或者 Comparable 维护了一个排序顺序。
                    </p>
                    <p style="text-align: left;">
                        4. Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。
                    </p>
                    <p style="text-align: left;">
                        5.Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用）
                    </p>
            
                </p>
            </section>

            <section>
                <p>
                    面试题：什么场景下使用list，set，map呢？
                    （或者会问为什么这里要用list、或者set、map，这里回答它们的优缺点就可以了）                
                </p>
            </section>


            </section>



            <!-- **************************************************** -->
        
            <section>
                
            <section>
                <h3>4.解决方案</h3>
            </section>

            <section>
                <p>
                    答：
                </p>
                <p>
                    1.如果你经常会使用索引来对容器中的元素进行访问，那么 List 是你的正确的选择。
                    如果你已经知道索引了的话，那么 List 的实现类比如 ArrayList 可以提供更快速的访问,如果经常添加删除元素的，那么肯定要选择LinkedList。
                </p>
                <p>
                    2.如果你想容器中的元素能够按照它们插入的次序进行有序存储，那么还是 List，因为 List 是一个有序容器，它按照插入顺序进行存储。
                </p>

            </section>
            <section>
                <p>
                    3.如果你想保证插入元素的唯一性，也就是你不想有重复值的出现，那么可以选择一个 Set 的实现类，比如 HashSet、LinkedHashSet 或者 TreeSet。
                    所有Set的实现类都遵循了统一约束比如唯一性，而且还提供了额外的特性比如 TreeSet 还是一个 SortedSet，所有存储于 TreeSet 中的元素可以使用 Java 里的 Comparator 或者
                    Comparable
                    进行排序。LinkedHashSet 也按照元素的插入顺序对它们进行存储。
                </p>
            
                <p>
                    4.如果你以键和值的形式进行数据存储那么 Map 是你正确的选择。你可以根据你的后续需要从 Hashtable、HashMap、TreeMap 中进行选择。
                </p>
            </section>
            
            </section>
            <!-- **************************************************** -->

            <section>
                <h3>5.编码实战</h3>
                <h1>Code</h1>
            </section>

            <!-- **************************************************** -->

            <section>

            <section>
                <h3>6.拓展思考</h3>
            </section>
            
            <section>
                <h4>java是如何定位元素位置的？</h4>
            </section>

            <section>
                <p>
                    通过hashcode定位。
                </p>
                <h4>在集合内放入元素时放入值相同不同引用和相同引用的区别</h4>
            </section>

            </section>
            <!-- **************************************************** -->


            <section>
                <h3>7.参考文献</h3>
                <p>Java集合类: Set、List、Map、Queue使用场景梳理</p>
                <p>http://www.cnblogs.com/LittleHann/p/3690187.html</p>
                <p>List、Set、Map的区别</p>
                <p>https://www.cnblogs.com/IvesHe/p/6108933.html</p>
            </section>


            <!-- **************************************************** -->

            <section>
                <h3>8.更多讨论</h3>
                <p>欢迎师兄加入讨论</p>
            </section>

            <!-- **************************************************** -->

            <section>
                <h4>鸣谢</h4>
                <p>魏振恒师兄</p>
                <p>感谢大家观看</p>
                <p>BY : 李浩</p>
            </section>

        </div>
    </div>

    <script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
    <script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

    <script>

        // 以下为常见配置属性的默认值
        // {
        // 	controls: true, // 是否在右下角展示控制条
        // 	progress: true, // 是否显示演示的进度条
        // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
        // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
        // 	keyboard: true, // 是否启用键盘快捷键来导航
        // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
        // 	center: true, // 是否将幻灯片垂直居中
        // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
        // 	loop: false, // 是否循环演示
        // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
        // 	fragments: true, // 全局开启和关闭碎片。
        // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
        // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
        // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
        // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
        // }

        // 初始化幻灯片
        Reveal.initialize({
            history: true,
            dependencies: [
                { src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js' },
                { src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js' },
                { src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true },
                { src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
            ]
        });
    </script>
</body>

</html>